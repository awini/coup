## Краткий туториал

### Что имеем?
Код на **Python**, который нужно перевести в **JS**. Возьмем для примера самописную функцию вычисления факториала:

```Python
def fact(num):
    rval = 1
    i = 2
    while i <= num:
        rval = rval * i
        i += 1
    return rval
```

### Как будем делать ?
Разница между простыми инструкциями **Python** и **Javascript** не так велика.
Попробуем описать недостающие соответствия:

1. Умножение:
```
<EXP> * <EXP>                       >>>     <EXP> * <EXP>                               >>>     Multiply
```
    В обоих языках эта инструкция выглядит одинаково. Однако для того, чтобы перевод состоялся, необходимо это соответствие задать.

Обратите внимание, что словом `<EXP>` обозначаем место, где может быть вложенная инструкция.

2. Меньше-равно и вывод результата функции задаются аналогично:
```
<EXP> <= <EXP>                      >>>     <EXP> <= <EXP>                              >>>     Lower
return <EXP>                        >>>     return <EXP>                                >>>     ReturnVal
```
3. Цикл **while**:
```
while <EXP>:                        >>>     while (<EXP>) {                             >>>     While
```
В **Python** нет круглых скобок, а начало вложенного блока ознаменовывается двоеточием.
В **Javascript** же начало блока обозначается фигурной скобкой.

Идем далее.

4. Создание функции с 1 аргументом:
```
def <EXP:+NAME>(<EXP:+NAME>):       >>>     function <EXP:+NAME>(<EXP:+NAME>) {         >>>     func_1          | locals = {}
```
    Здесь <EXP:+NAME> изначает создание имени (или локальной переменной).
    Таким образом в этом месте может быть только конструкция без спецсимволов и пустот.
    И при обнаружении такой конструкции в словарь локальных переменных будет добавлено найденное имя.

5. Запуск функции с 1 аргументом:
```
<EXP>(<EXP>)                        >>>     <EXP>(<EXP>)                                >>>     func_start_1
```
    Такая конструкция работает для нашей цели потому, что не найдя другой более подходящей инструкции,
    библиотека проверяет эту инструкцию и получает положительный результат. Дело в том, что в <EXP>
    может быть подставлено имя локальной переменной, если такая существует. Заметьте, что предыдущим шагом
    мы обозначили добавление имени функции в локальные переменные, что и помогает здесь.

Ну и для завершения перевода:

7. Вывод на экран:
```
print(<EXP>)                        >>>     console.log(<EXP>)                          >>>     Print
```

Хорошо, самое время создать тестовый файл **tst.py**. Добавим в него следующий код:

```python
from coup.common.url import think

Py2Js = think('''
    @:extends:Common
    @langs
    def <EXP:+NAME>(<EXP:+NAME>):       >>>     function <EXP:+NAME>(<EXP:+NAME>) {         >>>     >>>     func_1          | locals = {}
    def <EXP:+NAME>(<EXP:+NAMES_LIST>): >>>     function <EXP:+NAME>(<EXP:+NAMES_LIST>) {   >>>     >>>     func_2          | locals = {}
    <EXP>(<EXP>)                        >>>     <EXP>(<EXP>)                                >>>     >>>     func_start_1
    <EXP>(<EXP:LIST>)                   >>>     <EXP>(<EXP:LIST>)                           >>>     >>>     func_start_2
    while <EXP>:                        >>>     while (<EXP>) {                             >>>     >>>     While
    <EXP> <= <EXP>                      >>>     <EXP> <= <EXP>                              >>>     >>>     Lower
    <EXP> * <EXP>                       >>>     <EXP> * <EXP>                               >>>     >>>     Mnoz
    return <EXP>                        >>>     return <EXP>                                >>>     >>>     ReturnVal
    print(<EXP>)                        >>>     console.log(<EXP>)                          >>>     >>>     Print
    ''', lang='Javascript')
out = Py2Js.translate('', remove_space_lines=True)
```
Выведем на экран результат:
```
print(out)
```

И увидим, каким получился наш перевод:

 ```
 function fact(num)
 {
    var rval = 1
    var i = 2
    while (i <= num)
    {
        rval = rval * i
        i += 1
    }
    return rval
}
```

### А если кода много, очень много? 
Время, пицца и хорошая музыка.

### Или… 
# Coup:
```python
from coup.common.url import think
from coup.common.all import Common
lang = 'Javascript'

Py2Js = think(translater=Common, lang=lang)
out = Py2Js.translate(source_file, remove_space_lines=True)

for line in out.split('\n'):
   print(line)

console.log('Hello world')
```

Таким мы получим код на JS:
```
function fact(num)
{
    var rval=1;
    for (var i = 2; i <= num; i++)
        rval = rval * i;
    return rval;
}
```

**Coup** создан для перевода из одного языка программирования в другой. Не важно, о каких языках речь, главное иметь правильный **словарь**, который опишет все **инструкции**.

Как видно из примера выше – пользоваться им легко.

Немного о **словаре**…
Каждая строка в словаре определяет **инструкцию** будь то a=1 или a.call().
Пример:
```
a = 1 >>> a = 1
```
Символы >>> определяют границы **инструкции** для языка.
tip: для большой **инструкции** можно использовать ||| что бы разместить ее в несколько строчек.
```
for a in b: >>> for (var a = 0, 
                   ||| a <b, 
                   ||| a++)
```
Любое **количество** инструкций может находиться в строке исходного кода.
Любая инструкция должна иметь свою уникальное имя. Имя инструкции не должно встречаться в ее определение.
```
If a > 1 >>> if (a>1) >>> IF_INSTRUCTION
```
Для определения языка, используйте ===язык===
```
===python===          ===js===
a = 1                >>>     var a = 1;         >>> SOME_INSTRUCTION
```
Для добавления комментария в словарик используйте -------
```
------- here some simple logic -----
```
Для задачи стандартных параметров перевода используется :::
``` 
                ::: simple_line_end = ;
```
Доступные параметры:
**simple_line_end** – символ окончания инструкции (например ;)
**var_format** – символ при использовании переменных (например $)
**insert_childs** – (???)
**_ignore_start_block** (???)
**Что еще?**

**<EXP>** обозначается выражение. Оно переводится без изменений.
```
If <EXP> >>> if  (<EXP>)
```
<EXP:name> обозначается какое-либо имя переменной.
```
<EXP:name> = <EXP> >>> <EXP:name> = <EXP>
```
<EXP:LIST> используется для обозначение массива. Количество элементов массива должно быть больше 1 и их перечисление происходит через запятую.
```
(<EXP:LIST>) >>>  [<EXP:LIST>]
<EXP:name> = >>> var <EXP:name> =
```
Такое сочетание инструкций можно использовать ля перевода строчки

a = (1,2,3) в var a = [1,2,3]

Дополнительные параметры EXP:
**<EXP:object_of>**
**<EXP:instance_of>**
**<EXP:^exp_arg>**
**<EXP:+instance_arg>**
**<EXP:^arg_from_instance>**

